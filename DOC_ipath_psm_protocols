
https://www.youtube.com/watch?v=rbB2drMqGPU

++++++++++++++Notes+++++++++++++++
The Intel® Performance Scaled Messaging 2 (Intel® PSM2) API is a high-performance, vendor-specific protocol that provides a low-level communications interface for the Intel® Omni-Path family of products. PSM2 enables mechanisms necessary to implement higher levelcommunications interfaces in parallel environments.

PSM2 targets clusters of multicore processors and transparently implements two levels of communication: inter-node communication and intra-node shared memory communication.

PSM2 includes new features and optimizations for Intel® Omni-Path hardware and processors

PSM2 supports a larger 96-bit tag format, while Intel® True Scale PSM only supports 64-bit tags.

PSM2 is currently a single-threaded library. This means that you cannot make any concurrent PSM2 library calls. 


---- Endpoints -----
PSM2 follows an endpoint communication model where an endpoint is defined as an object (or handle) instantiated to support sending and receiving messages to other endpoints. In order to prevent PSM2 from being tied to a particular parallel model (such as SPMD), you retain control over the parallel layout of endpoints. Opening endpoints (psm2_ep_open) and connecting endpoints to enable communication (psm2_ep_connect) are two decoupled mechanisms

As a side effect, this greater flexibility allows you to manage a two-stage initialization process. In the first stage of opening an endpoint (psm2_ep_open), you obtain an opaque handle to the endpoint and a globally distributable endpoint identifier (psm2_epid_t). Prior to the second stage of connecting endpoints (psm2_ep_connect), you must distribute all relevant endpoint identifiers through an out-of-band mechanism. Once the endpoint identifiers are successfully distributed to all processes that wish to communicate, you connect all endpoint identifiers to the locally opened endpoint (psm2_ep_connect).

-------- Components -------
PSM2 exposes a single endpoint initialization model, but enables various levels of communication functionality and semantics through components. The first major component available in PSM2 is PSM2 Matched Queues (Intel® PSM2 Component Documentation on page 23). Matched Queues (MQ) present a queue-based communication model with the distinction that queue consumers use a 3-tuple of metadata to match incoming messages against a list of preposted receive buffers. The MQ semantics are sufficiently akin to MPI to cover the entire MPI-1.2 standard. With future releases of the PSM2 interface, more components may be exposed to accommodate users who implement parallel communication models that deviate from the Matched Queue semantics.

MQ messages are either received as expected or unexpected:
• The received message is expected if the incoming message tag matches the combination of tag and tag selector of at least one of the user-provided receive buffers preposted with psm2_mq_irecv or psm2_mq_irecv2.
• The received message is unexpected if the incoming message tag doesn't match any combination of tag and tag selector from all the user-provided receive buffers preposted with psm2_mq_irecv or psm2_mq_irecv2.

A successful MQ tag match requires a 3-tuple of unsigned 96-bit ints, two of which are provided by the receiver when posting a receive buffer (psm2_mq_irecv and psm2_mq_irecv2) and the last is provided by the sender as part of every message sent (psm2_mq_send and psm2_mq_isend). Since MQ is a receiver-directed communication model, the tag matching done at the receiver involves matching a sent message send tag (stag) with the tag (rtag) and tag selector (rtagsel) attached to every preposted receive buffer. The incoming stag is compared to the posted rtag but only for significant bits set in the rtagsel. The rtagsel can be used to mask off parts (or even all) of the bitwise comparison between sender and receiver tags. A successful match causes the message to be received into the buffer with which the tag is matched.

---------- semantics and progression ------------
Message completion in Matched Queues follows local completion semantics. When sending an MQ message, it is deemed complete when MQ guarantees that the source data has been sent and that the entire input source data memory location can be safely overwritten. As with standard Message Passing, MQ does not make any remote completion guarantees for sends.

explicitly ensure progress on MQs for correctness. The progress requirement holds even if certain areas of the MQ implementation require less network attention than others, or if progress may internally be guaranteed through interrupts. The main polling function, psm2_poll, is the most general form of ensuring progress on a given endpoint. Calling psm2_poll ensures that progress is made over all the MQs and other components instantiated over the endpoint passed to psm2_poll.
While psm2_poll is the only way to directly ensure progress, other MQ functions conditionally ensure progress depending on how they are used 

psm2_mq_wait and psm2_mq_wait2 employ polling and wait until the request is completed. For blocking communication operations where the caller is waiting on a single send or receive to complete, psm2_mq_wait or psm2_mq_wait2 usually provides the best responsiveness in terms of latency.
• psm2_mq_test and psm2_mq_test2 test a particular request for completion, but never directly or indirectly ensure progress because they only test the completion status of a request, nothing more. See functional documentation for psm2_mq_test and psm2_mq_test2 for details.


Infiniband Verbs----------------
The InfiniBandTM standard offers different transport services like stream or datagram to the user.
Each transport service has special features and shows different communication times and overheads. Additionally, different transport functions can be performed with each transport service
(see Table 36 at Page 245 in the InfiniBandTM specification [199]). We call a combination of transport function and transport service transport type. All different transport types have to be analyzed
in order to draw an accurate conclusion for the implementation of a parallel algorithm or a collective operation. The different transport types are briefly explained in the following

This section briefly explains the different transport services that are defined in the InfiniBandTM
specification.
 * Unreliable Connection The Unreliable Connection (UC) offers point-to-point transmission based
on unreliable connections without flow control. Packets may be silently discarded during transmission. A queue pair (QP) has to be created at each host and connected to each other in order to
transmit any data. The queue pair acts as a connection and endpoint identifier.
 * Reliable Connection The Reliable Connection (RC) is basically identical to UC despite the fact
that the correct in-order transmission of packets is guaranteed by the InfiniBandTM hardware. An
automatic retransmission and flow control mechanism is used to ensure correct delivery even if
slight network errors occur. The role of the QPs remains the same as for UC.
 * Unreliable Datagram The Unreliable Datagram (UD) transport type offers connectionless data
delivery. The reception or in-order delivery is not guaranteed in this case. QPs are only used
to send or receive packets and each packet can have a different destination (they do not denote
a virtual channel as for UC/RC). A single datagram must not exceed the MTU of the network
(typically 2KiB).
 * Reliable Datagram The Reliable Datagram (RD) transport type adds a guaranteed reliable in
order delivery to UD. QPs can be used to reach any target as in the UD case. RD is currently not
supported in our test system.
RAW The RAW Transport type can be used to encapsulate other transmission protocols as Ethernet or IPv6. It has nearly the same characteristics as UD and will not be discussed in the following.

In this section, the possible transport functions are discussed and bound to a specific transport type
for the benchmark.
Send The simple send function is available for all IBA transport services and will be measured
for all of them.
RDMA Write The Remote Direct Memory Access Write (RDMA-W) can write to explicitly registered memory at a target without the need to interrupt the target’s CPU. RDMA-W can be used atop
RC, UC and RD. We present results for RDMA-W atop RC because RD is currently not supported.
RDMA Read The Remote Direct Memory Access Read (RDMA-R) can read from registered memory at a target system without influencing the remote CPU. RDMA-R can be used atop RC and RD.
We present results for RDMA-R atop RC because RD is currently not supported.
Atomic Operations Atomic Operations (AO) can be useful to support interprocess synchronization calls. Our current system does not support the optional AOs and we cannot present any measurement values.

[cite -- Infiniband specification]
############ Infinipath - PSM

Infiniband standard specifies transport services for RDMA based communication. 
In general Infiniband advocates different types of transport services and functions that may be performed on the service. However not all hardware vendors may support all aspects of the specification, while some others may support only a minimal subset. Thus capabilities and features may vastly differ depending on the fabric HCA vendor. Following explains the transport services that are defined in the InfiniBandTM specification.

RC (Reliable Connection) -- Specifies connection oriented (i.e. state-full) tranport protocol. The connection is also a reliable point to point transmission protocols with flow control enabled. Thus messages are delivered in order without loss. Because of the reliability guarantees this mode of transports may have a higher cost associated with it.
UC (Unreliable Connection) -- Specifies a connection oriented transport service without flow control. Packets may be siliently dropped during transmission. Thus, this mode of transport may guarantee in-order delivery, but all packets may not be delivered. 
RD (Reliable Datagram) -- Specifies a connection less (i.e. state less) transport service without packet loss and flow control. Thus this mode of transport does not guarantee in-order delivery. 
RD (Unreliable Datagram) -- Specifies a connection less (i.e. state less) transport service that does not guarantee reception or in-order delivery. 



All aforementioned Infiniband RC, UC, UD, RD services may be backed up by one sided RDMA read, write, atomic operations as well as loosely two-sided Send/Recv type operations. As noted earlier, the software support for fine grained opeartions and QP completion events/notifications may differ by the vendor. Variants of Infiniband implementations are also present in Intel and Qlogic fabrics. Similar to Cray and other Infiniband systems these HCAs may vary widely in hardware features supported and the protcol mode features for RDMA.
We utilized Intel Performance Scaled Messaging(PSM) library to build a base infiniband ``backend'' 'implementation for \rmalloc. PSM API~\footnote{PSM comes in two flavours PSM and PSM2 that was supported on Infini-path and Omni-patg family of products respectively. PSM and PSM support 64-bit and 96-bit tag formats respectively} is a high performance vendor specific protocol which provides a low level communication interface for Intel Omni/Infi-Path family of products. PSM API's target shared memory and internode modes for communication. Because PSM in general carries hardware specific optimizations in its userspace driver library, it exhibits greater performance enhancements for native HCAs than using Infiniband Verbs or similar library adapted for the Intel driver.
PSM2 also follows an endpoint based communication model where one or more endpoints are initiated per node before any communication takes place. The initiation phase is loosely coupled into two stages. In the first stage, user opens an endpoint (\texttt{psm\_ep\_open}), to obtain an opaque handle for all connect, communication and progress functions. Just before the second stage of connecting endpoints (\texttt{psm\_ep\_connect}), user distributes all relevant endpoint identifiers through an out-of-band bootstrap mechanism. Once the endpoint identifiers are successfully distributed to all processes that wish to communicate, the may be used to connect to the remote endpoint.

Although PSM2 exposes a single endpoint initialization model, it enables various levels of communication functionality and semantics via its components. Two major components available in PSM and PSM2 are Matched Queues and Active Messages. Matched Queues (PSM MQ) present a queue-based communication model with the distinction that queue consumers may use tags to match incoming messages against a list of posted receive requests (\texttt{psm\_mq\_irecv}). Active messaging mode (PSM AM) follows the active message semantics where a remote handler is executed from a set of pre registered PSM handler functions. However, AM mode does not expose any direct RDMA buffers or routines. In MQ mode, a loose two sided RDMA semantics are followed for large messages with actual transfer being performed after a succesful match. Message completion in MQ mode follows local completion and thus source data is generally safe for reuse. Unlike MPI, PSM requires explicit network operations or implicit conditional operations to ensure network progress. For example , \texttt{psm\_poll}, is the most general form of ensuring progress on a given endpoint. Other progress operations such as \texttt{psm\_wait} and \texttt{psm\_test} may wait or test until progress is made on a single request. Other esoteric forms of progression such as \texttt{psm\_ipeek} that functions to query a particular MQ for non-blocking requests that are ready for completion.  Although requests "ready for completion" are not generally considered complete by MQ until they are returned to the MQ library through \texttt{psm\_wait} or \texttt{psm\_test}. 

MQ messages are either received as expected or unexpected. The received message is expected if the incoming message tag matches the combination of tag and tag selector of at least one of the user-provided receive buffers preposted with psm2_mq_irecv or psm2_mq_irecv2.
• The received message is unexpected if the incoming message tag doesn't match any combination of tag and tag selector from all the user-provided receive buffers preposted with psm2_mq_irecv or psm2_mq_irecv2.

PSM/IPS-PTL Low level protocols
-------------------------------



PSM's high level packet transport layer protocol (PTL) is responsible for reliably transfering packets over from local endpoint to the destinaton.
In recieve progress loop, PSM tries to test whether any of the requests are matched with the requests located in the expected queue. If any match was not found incoming requests are moved into a special queue called unexpected queue.
For each recieve request, they are also matched against the expected requests. Again If this matching fails then incoming request is appended to the expected queue.
In case of a succesful recieve match or send request, PSM triggers the respective protocol control flow to retrieve or transfer the message.

PSM use 2 different low level transport modes for RDMA. 
a) PIO -- programmed IO
b) SDMA -- Asynchronous DMA requests

For eager messages the payload is generally contained along with the metadata and PIO method is used. In this case sender packs the matching tags and source information and then sends the request using PIO. 
Sometimes if the message is too small then a payload is not sent. Instead, data is inlined with the PIO message header (psm send control block(scb) header). A PIO request is handled by enqueing the request in a PIO send queue and then trigerring an interrupt timer or fommand. This will eventually write the PIO descriptors to the NIC. Medium sized messages may be handled different where the PTL layer may fragment the message into MTU packets for send and reliable delivery is taken care of.
A rendezvous protocol is implemented for Large messages in two stages. 
A succesful match triggers a request to initiate the actual large message transfer. 
PSM employs two methods for rendezvous RDMA. 
  a) Eager send back
  b) Expected TID transfer 

In Eager send, First the initiator send a RTS control request (with a reference to the initiating request) along with matching metadata. 
A succesful match then triggers a CTS request from the reciever side to initiate sending payload. Once CTS acknowledgement is recieved, the initiator may start transfering payload in MTU packets using PIO.

A more efficient method is to switch to an expected TID protocol where initiator sends the token for SDMA buffer along with meta data. In this case the reciever registers an expected TID token get operation for the reciever RDMA buffer and then sends a control packet with requested matching token (sent by the initator) to start the transfer. 
Get requests, issued by MQ when there's a match on a large message.  Unlike an RDMA get, the initiator identifies the location of the data at the target using a 'send token' instead of a virtual address.  This, of course, assumes that the target has already registered the token and communicated it to the initiator beforehand (it actually sends the token as part of the initial MQ message that contains the MQ tag). The operation is semantically a two-sided RDMA get.

Once the request is recieved a DMA transfer is taken place corresponding to the buffer location that will send data from DMA buffer to the NIC interface destined towards the reciever side. 
Reciever side will trigger another DMA transfer from incoming packets to its recieve buffers and request is completed once all packets are transferred.

